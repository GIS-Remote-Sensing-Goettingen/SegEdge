"""Minimal S2DR3 pipeline built from the reverse-engineered components.

The vendor binary performs two main stages:

1. A ViT-L/16 feature extractor (captured in :mod:`vit_s2dr3_backbone`).
2. A super-resolution decoder (:mod:`s2dr3_decoder.S2x10NetS`) that consumes the
   10-band low-resolution cube and produces a 10× upsampled product.

This module wires the pieces together without ever loading the full 400 MB state
dict into RAM.  Use :func:`load_superres_decoder` to stream the weights from the
``weights/`` directory generated by the shim hooks, and call
:meth:`S2DR3Pipeline.super_resolve` with the preprocessed multispectral stack.

Warning:
    The original pipeline expects pre-whitened Sentinel-2 L2A data arranged as
    ``(B, 10, 480, 480)``.  Replicating the vendor preprocessing (cloud masks,
    contrast stretching, etc.) is out of scope here.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Optional

import torch

from s2dr3_decoder import S2x10NetS, load_s2x10_from_chunks
from vit_s2dr3_backbone import VisionTransformerS2DR3, load_backbone_from_safetensors


@dataclass
class PipelineArtifacts:
    backbone: VisionTransformerS2DR3
    decoder: S2x10NetS


def load_pipeline(
    backbone_ckpt: Path | str,
    decoder_dir: Path | str,
    device: Optional[torch.device] = None,
) -> PipelineArtifacts:
    """Load both the ViT backbone and the streamed super-resolution decoder."""

    backbone = load_backbone_from_safetensors(str(backbone_ckpt), device=device)
    decoder = load_s2x10_from_chunks(decoder_dir)
    if device is not None:
        decoder.to(device)
    return PipelineArtifacts(backbone=backbone, decoder=decoder)


class S2DR3Pipeline:
    """Convenience wrapper that mirrors the public S2DR3 interface."""

    def __init__(self, artifacts: PipelineArtifacts, device: Optional[torch.device] = None):
        self.backbone = artifacts.backbone
        self.decoder = artifacts.decoder
        self.device = device or torch.device("cpu")

    @torch.inference_mode()
    def super_resolve(self, ms_cube: torch.Tensor) -> torch.Tensor:
        """Run the decoder on a low-resolution 10-band cube.

        Args:
            ms_cube: Tensor with shape ``(B, 10, H, W)``.  The vendor model
                expects ``H=W=480`` but the decoder itself is fully convolutional.

        Returns:
            Tensor of shape ``(B, 10, H*10, W*10)``.
        """

        ms_cube = ms_cube.to(self.device)
        self.decoder.eval()
        return self.decoder(ms_cube)

    @torch.inference_mode()
    def extract_tokens(self, rgb: torch.Tensor) -> torch.Tensor:
        """Optional helper that forwards an RGB crop through the ViT backbone."""

        rgb = rgb.to(self.device)
        _, tokens = self.backbone(rgb)
        return tokens
